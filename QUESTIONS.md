# Вопросы:

* Какой самый эффективный способ конкатенации строк?

В Go самым эффективным способом конкатенации большого количества строк является использование типа strings.Builder. Этот метод более предпочтителен, чем простое использование оператора + или функции fmt.Sprintf, так как strings.Builder минимизирует количество необходимых аллокаций памяти и копирования данных.
```go
var builder strings.Builder
for _, str := range strings {
    builder.WriteString(str)
}
result := builder.String()
```

* Что такое интерфейсы, как они применяются в Go?

Интерфейс это контракт, которому соответствовать структуры. Интерфейсы в Go позволяют реализовать полиморфизм и абстракцию, предоставляя возможность использовать различные типы, которые имеют одинаковый набор методов, в унифицированном контексте. Это очень мощный инструмент для создания гибких и масштабируемых приложений.

* Чем отличаются RWMutex от Mutex?

sync.Mutex и sync.RWMutex из пакета sync в Go предоставляют средства для синхронизации доступа к данным между горутинами. Mutex предоставляет эксклюзивную блокировку, что означает, что только одна горутина может захватить блокировку для чтения или записи данных. RWMutex (Read-Write Mutex) различает блокировки для чтения и записи: блокировка для записи работает так же, как и Mutex, но блокировка для чтения может быть захвачена несколькими горутинами одновременно, если нет активной блокировки для записи, что улучшает производительность при частых операциях чтения.

* Чем отличаются буферизированные и не буферизированные каналы

Буферизированные каналы в Go позволяют хранить ограниченное количество сообщений без необходимости немедленного приема сообщения получателем. Канал блокируется только тогда, когда буфер заполнен. Небуферизированные каналы не имеют хранилища для сообщений; они блокируют отправителя до тех пор, пока получатель не извлечет сообщение, обеспечивая синхронизацию на каждой операции отправки.

* Какой размер у структуры struct{}{}?

Структура struct{}{} в Go имеет размер 0 байт. Это пустая структура, которая часто используется для сигнализации или в качестве заполнителя, так как она не занимает никакого пространства в памяти.

* Есть ли в Go перегрузка методов или операторов?

В Go нет поддержки перегрузки методов или операторов. Каждая функция или метод в пакете должны иметь уникальное имя. Это упрощает язык и уменьшает сложность, связанную с перегрузкой функций, характерной для некоторых других языков программирования.

* В какой последовательности будут выведены элементы map[int]int?

map могут быть выведены в любом порядке, и этот порядок может меняться при каждом запуске программы. Таким образом, невозможно гарантировать или предсказать порядок, в котором элементы будут выведены.

* В чем разница между make и new?

    * new(T) выделяет память для типа T и возвращает указатель на неинициализированную область памяти типа *T. По сути, new(T) инициализирует новый объект типа T с нулевыми значениями его полей и возвращает указатель на него.
    * make(T, args) используется для инициализации и выделения памяти для слайсов, карт и каналов, которые являются составными типами данных в Go. Функция make возвращает инициализированный (не нулевой) объект типа T, а не указатель.

* Сколько существует способов задать переменную типа slice или map?

* Для slice и map существует несколько способов инициализации:

    * Slice:
        * Через make: s := make([]int, 0)
        * Через литерал: s := []int{}
    * Map:
        * Через make: m := make(map[int]int)
        * Через литерал: m := map[int]int{} или m := map[int]int{1: 2, 3: 4}

* Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p) // Выведет 1
  update(p)
  fmt.Println(*p) // Снова выведет 1
}
```

* Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Программа может завершиться с ошибкой или неправильно работать, поскольку WaitGroup передается по значению, а не по ссылке, в горутины. Каждая горутина получает свою копию WaitGroup, и вызов Done() не влияет на оригинальный WaitGroup в main.

* Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Ответ: 0

* Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

Ответ: Программа выведет [100 2 3 4 5]

* Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

Ответ: Программа выведет ["b", "b", "a"] ["b", "b"]